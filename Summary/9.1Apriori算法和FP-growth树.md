# Apriori算法
从大规模数据集中寻找物品间的隐含关系被称作为*关联分析*或者*关联规则学习*。  
关联分析是一种在大规模数据集中寻找有趣关系的任务。这种关系可以有两种性质：**频繁项集**或者**关联规则**。
> 频繁项集是机场出现在一块的物品的集合。即(A,B)同时出现的可行性大。  
> 关联规则暗示两个物品之间可能存在很强的关系。例如人们购买了A，很有可能也会购买B。

- 频繁项集可以使用**支持度**来表示。支持度定义为数据集中包含该项集的记录所占的比例。例如{面包}的支持度为4/5，而{面包，牛奶}在五条记录中出现了3次，所以支持度为3/5.  
- 关联规则可以使用**可信度**来表示。可信度或者置信度是针对诸如{面包}->{牛奶}的关联规则来定义的。一条规则的可信度被定义为`支持度({面包，牛奶})/支持度({面包})`。例如{面包}->{牛奶}的可行度为`(3/5)/(4/5)=3/4`。  

支持度和可信度是用来量化关联分析是否成功的方法。
![](https://img-blog.csdn.net/20161124164716838)  

## Apriori原理
1. 如果某个项集是频繁的，那么它的所有子集也是频繁的。
2. 逆否命题：如果一个项集是非频繁的，那么它的所有超集也是非频繁的。
3. 如果某条规则不满足最小可信度要求，那么该规则的所有子集也不会满足最小可信度要求。

首先需要找到频繁项集，然后才能获得关联规则。

> 计算频繁项集  
**该算法说先会生成所有单个物品的项集列表，接着数据集来查看哪些项集满足最小支持度要求，那些不满足最小支持度的集合会被去掉。然后，对剩下的集合进行组合以生成包含两个元素的项集。接下来，再重新扫描数据集，去掉不满足最小支持度的项集。该过程重复进行到所有项集都被去掉。**    

![](https://img-blog.csdn.net/20161206104307033)


> 计算关联规则  
**首先从一个频繁项集开始，接着创建一个规则列表，其中规则又不只包含一个元素，然后对这些规则进行测试。接下来合并所有剩余规则来创建一个新的规则列表，其中规则又不包含两个元素。这种方法也被称作分级法。**

[文章1](https://blog.csdn.net/baimafujinji/article/details/53456931),[文章2](https://blog.csdn.net/zhazhayaonuli/article/details/53322541?locationNum=15&fps=1)


# FP-growth树
FP-frowth是基于Apriority构建的，这里的任务是将数据集存储在一个特定的称作FP树的结构之后发现频繁项集。该算法只能用于发现**频繁项集**。  
FP-growth算法只需要对数据进行两次扫描，而Apriori算法对于每个潜在的频繁项集都会扫描数据集判定给定模式是否频繁，因此FP-growth算法的速度要比Apriori算法块。其基本过程如下：
1. 构建FP树
2. 从FP树中挖掘频繁项集

![](https://img-blog.csdn.net/20170505201626861?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTcxOTY5OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)  
同搜索树不同的是，一个元素项可以在一棵FP树中出现多次。FP树会存储项集的出现频率，而每个项集会以路径的方式存储在树中。存在相似元素的集合会共享树的一部分。只有当集合之间完全不同时，树才会分叉。树节点上给出集合中的单个元素及其在序列中的出现次数，路径会给出该序列的出现次数。  
相似项之间的链接即节点链接，用于快速发现相似项的位置。

## FP树构建
为了构建FP树，需要对数据进行2次扫描。第一遍扫描用于统计出现的频率，第二次扫描中只考虑那些频繁元素。  
这里需要一个头指针表，用于记录元素和出现的频率。

## 挖掘频繁项集
挖掘频繁项集的三个基本步骤如下：
1. 从FP树中获得条件模式基;
2. 利用条件模式基,构建一个条件FP树;
3. 迭代重复步骤(1)步骤(2),直到树包含一个元素项为止。

**条件模式基**是以所查找元素项为结尾的路径集合。每一条路径其实都是一条**前缀路径**，一条前缀路劲是介于所查找元素项与树根节点之间的所有内容。每一条前缀路劲都与一个计数值关联，该计数值等于其还是元素项的计数值，该计数值给了每条路径上X的数目。

1. 首先对头指正表从小到大排序，然后循环每个元素
2. 例如第一次循环的元素是t，将{t}加入频繁项集中，然后寻找t的条件模式基。接着利用条件模式基来构建条件FP树。当条件模式基里面的计数值不满足最小支持度时，会被删除；档满足最小支持度时，迭代构建树，直至无元素或者元素不满足条件位置。

[这一篇文章很好的介绍了FP树](https://www.cnblogs.com/zhengxingpeng/p/6679280.html)